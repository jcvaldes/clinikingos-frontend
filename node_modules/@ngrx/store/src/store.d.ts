import { Provider } from '@angular/core';
import { Observable, Observer, Operator } from 'rxjs';
import { ActionsSubject } from './actions_subject';
import { Action, ActionReducer } from './models';
import { ReducerManager } from './reducer_manager';
import { StateObservable } from './state';
import * as ɵngcc0 from '@angular/core';
export declare class Store<T> extends Observable<T> implements Observer<Action> {
    private actionsObserver;
    private reducerManager;
    constructor(state$: StateObservable, actionsObserver: ActionsSubject, reducerManager: ReducerManager);
    select<K>(mapFn: (state: T) => K): Observable<K>;
    select<K, Props = any>(mapFn: (state: T, props: Props) => K, props: Props): Observable<K>;
    select<a extends keyof T>(key: a): Observable<T[a]>;
    select<a extends keyof T, b extends keyof T[a]>(key1: a, key2: b): Observable<T[a][b]>;
    select<a extends keyof T, b extends keyof T[a], c extends keyof T[a][b]>(key1: a, key2: b, key3: c): Observable<T[a][b][c]>;
    select<a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c]>(key1: a, key2: b, key3: c, key4: d): Observable<T[a][b][c][d]>;
    select<a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c], e extends keyof T[a][b][c][d]>(key1: a, key2: b, key3: c, key4: d, key5: e): Observable<T[a][b][c][d][e]>;
    select<a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c], e extends keyof T[a][b][c][d], f extends keyof T[a][b][c][d][e]>(key1: a, key2: b, key3: c, key4: d, key5: e, key6: f): Observable<T[a][b][c][d][e][f]>;
    /**
     * This overload is used to support spread operator with
     * fixed length tuples type in typescript 2.7
     */
    select<K = any>(...paths: string[]): Observable<K>;
    lift<R>(operator: Operator<T, R>): Store<R>;
    dispatch<V extends Action = Action>(action: V): void;
    next(action: Action): void;
    error(err: any): void;
    complete(): void;
    addReducer<State, Actions extends Action = Action>(key: string, reducer: ActionReducer<State, Actions>): void;
    removeReducer<Key extends Extract<keyof T, string>>(key: Key): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<Store<any>, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<Store<any>>;
}
export declare const STORE_PROVIDERS: Provider[];
export declare function select<T, Props, K>(mapFn: (state: T, props: Props) => K, props?: Props): (source$: Observable<T>) => Observable<K>;
export declare function select<T, a extends keyof T>(key: a, props: null): (source$: Observable<T>) => Observable<T[a]>;
export declare function select<T, a extends keyof T, b extends keyof T[a]>(key1: a, key2: b): (source$: Observable<T>) => Observable<T[a][b]>;
export declare function select<T, a extends keyof T, b extends keyof T[a], c extends keyof T[a][b]>(key1: a, key2: b, key3: c): (source$: Observable<T>) => Observable<T[a][b][c]>;
export declare function select<T, a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c]>(key1: a, key2: b, key3: c, key4: d): (source$: Observable<T>) => Observable<T[a][b][c][d]>;
export declare function select<T, a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c], e extends keyof T[a][b][c][d]>(key1: a, key2: b, key3: c, key4: d, key5: e): (source$: Observable<T>) => Observable<T[a][b][c][d][e]>;
export declare function select<T, a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c], e extends keyof T[a][b][c][d], f extends keyof T[a][b][c][d][e]>(key1: a, key2: b, key3: c, key4: d, key5: e, key6: f): (source$: Observable<T>) => Observable<T[a][b][c][d][e][f]>;
/**
 * This overload is used to support spread operator with
 * fixed length tuples type in typescript 2.7
 */
export declare function select<T, Props = any, K = any>(propsOrPath: Props, ...paths: string[]): (source$: Observable<T>) => Observable<K>;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmUuZC50cyIsInNvdXJjZXMiOlsic3RvcmUuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmVyLCBPcGVyYXRvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQWN0aW9uc1N1YmplY3QgfSBmcm9tICcuL2FjdGlvbnNfc3ViamVjdCc7XG5pbXBvcnQgeyBBY3Rpb24sIEFjdGlvblJlZHVjZXIgfSBmcm9tICcuL21vZGVscyc7XG5pbXBvcnQgeyBSZWR1Y2VyTWFuYWdlciB9IGZyb20gJy4vcmVkdWNlcl9tYW5hZ2VyJztcbmltcG9ydCB7IFN0YXRlT2JzZXJ2YWJsZSB9IGZyb20gJy4vc3RhdGUnO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgU3RvcmU8VD4gZXh0ZW5kcyBPYnNlcnZhYmxlPFQ+IGltcGxlbWVudHMgT2JzZXJ2ZXI8QWN0aW9uPiB7XG4gICAgcHJpdmF0ZSBhY3Rpb25zT2JzZXJ2ZXI7XG4gICAgcHJpdmF0ZSByZWR1Y2VyTWFuYWdlcjtcbiAgICBjb25zdHJ1Y3RvcihzdGF0ZSQ6IFN0YXRlT2JzZXJ2YWJsZSwgYWN0aW9uc09ic2VydmVyOiBBY3Rpb25zU3ViamVjdCwgcmVkdWNlck1hbmFnZXI6IFJlZHVjZXJNYW5hZ2VyKTtcbiAgICBzZWxlY3Q8Sz4obWFwRm46IChzdGF0ZTogVCkgPT4gSyk6IE9ic2VydmFibGU8Sz47XG4gICAgc2VsZWN0PEssIFByb3BzID0gYW55PihtYXBGbjogKHN0YXRlOiBULCBwcm9wczogUHJvcHMpID0+IEssIHByb3BzOiBQcm9wcyk6IE9ic2VydmFibGU8Sz47XG4gICAgc2VsZWN0PGEgZXh0ZW5kcyBrZXlvZiBUPihrZXk6IGEpOiBPYnNlcnZhYmxlPFRbYV0+O1xuICAgIHNlbGVjdDxhIGV4dGVuZHMga2V5b2YgVCwgYiBleHRlbmRzIGtleW9mIFRbYV0+KGtleTE6IGEsIGtleTI6IGIpOiBPYnNlcnZhYmxlPFRbYV1bYl0+O1xuICAgIHNlbGVjdDxhIGV4dGVuZHMga2V5b2YgVCwgYiBleHRlbmRzIGtleW9mIFRbYV0sIGMgZXh0ZW5kcyBrZXlvZiBUW2FdW2JdPihrZXkxOiBhLCBrZXkyOiBiLCBrZXkzOiBjKTogT2JzZXJ2YWJsZTxUW2FdW2JdW2NdPjtcbiAgICBzZWxlY3Q8YSBleHRlbmRzIGtleW9mIFQsIGIgZXh0ZW5kcyBrZXlvZiBUW2FdLCBjIGV4dGVuZHMga2V5b2YgVFthXVtiXSwgZCBleHRlbmRzIGtleW9mIFRbYV1bYl1bY10+KGtleTE6IGEsIGtleTI6IGIsIGtleTM6IGMsIGtleTQ6IGQpOiBPYnNlcnZhYmxlPFRbYV1bYl1bY11bZF0+O1xuICAgIHNlbGVjdDxhIGV4dGVuZHMga2V5b2YgVCwgYiBleHRlbmRzIGtleW9mIFRbYV0sIGMgZXh0ZW5kcyBrZXlvZiBUW2FdW2JdLCBkIGV4dGVuZHMga2V5b2YgVFthXVtiXVtjXSwgZSBleHRlbmRzIGtleW9mIFRbYV1bYl1bY11bZF0+KGtleTE6IGEsIGtleTI6IGIsIGtleTM6IGMsIGtleTQ6IGQsIGtleTU6IGUpOiBPYnNlcnZhYmxlPFRbYV1bYl1bY11bZF1bZV0+O1xuICAgIHNlbGVjdDxhIGV4dGVuZHMga2V5b2YgVCwgYiBleHRlbmRzIGtleW9mIFRbYV0sIGMgZXh0ZW5kcyBrZXlvZiBUW2FdW2JdLCBkIGV4dGVuZHMga2V5b2YgVFthXVtiXVtjXSwgZSBleHRlbmRzIGtleW9mIFRbYV1bYl1bY11bZF0sIGYgZXh0ZW5kcyBrZXlvZiBUW2FdW2JdW2NdW2RdW2VdPihrZXkxOiBhLCBrZXkyOiBiLCBrZXkzOiBjLCBrZXk0OiBkLCBrZXk1OiBlLCBrZXk2OiBmKTogT2JzZXJ2YWJsZTxUW2FdW2JdW2NdW2RdW2VdW2ZdPjtcbiAgICAvKipcbiAgICAgKiBUaGlzIG92ZXJsb2FkIGlzIHVzZWQgdG8gc3VwcG9ydCBzcHJlYWQgb3BlcmF0b3Igd2l0aFxuICAgICAqIGZpeGVkIGxlbmd0aCB0dXBsZXMgdHlwZSBpbiB0eXBlc2NyaXB0IDIuN1xuICAgICAqL1xuICAgIHNlbGVjdDxLID0gYW55PiguLi5wYXRoczogc3RyaW5nW10pOiBPYnNlcnZhYmxlPEs+O1xuICAgIGxpZnQ8Uj4ob3BlcmF0b3I6IE9wZXJhdG9yPFQsIFI+KTogU3RvcmU8Uj47XG4gICAgZGlzcGF0Y2g8ViBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbj4oYWN0aW9uOiBWKTogdm9pZDtcbiAgICBuZXh0KGFjdGlvbjogQWN0aW9uKTogdm9pZDtcbiAgICBlcnJvcihlcnI6IGFueSk6IHZvaWQ7XG4gICAgY29tcGxldGUoKTogdm9pZDtcbiAgICBhZGRSZWR1Y2VyPFN0YXRlLCBBY3Rpb25zIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uPihrZXk6IHN0cmluZywgcmVkdWNlcjogQWN0aW9uUmVkdWNlcjxTdGF0ZSwgQWN0aW9ucz4pOiB2b2lkO1xuICAgIHJlbW92ZVJlZHVjZXI8S2V5IGV4dGVuZHMgRXh0cmFjdDxrZXlvZiBULCBzdHJpbmc+PihrZXk6IEtleSk6IHZvaWQ7XG59XG5leHBvcnQgZGVjbGFyZSBjb25zdCBTVE9SRV9QUk9WSURFUlM6IFByb3ZpZGVyW107XG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBzZWxlY3Q8VCwgUHJvcHMsIEs+KG1hcEZuOiAoc3RhdGU6IFQsIHByb3BzOiBQcm9wcykgPT4gSywgcHJvcHM/OiBQcm9wcyk6IChzb3VyY2UkOiBPYnNlcnZhYmxlPFQ+KSA9PiBPYnNlcnZhYmxlPEs+O1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gc2VsZWN0PFQsIGEgZXh0ZW5kcyBrZXlvZiBUPihrZXk6IGEsIHByb3BzOiBudWxsKTogKHNvdXJjZSQ6IE9ic2VydmFibGU8VD4pID0+IE9ic2VydmFibGU8VFthXT47XG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBzZWxlY3Q8VCwgYSBleHRlbmRzIGtleW9mIFQsIGIgZXh0ZW5kcyBrZXlvZiBUW2FdPihrZXkxOiBhLCBrZXkyOiBiKTogKHNvdXJjZSQ6IE9ic2VydmFibGU8VD4pID0+IE9ic2VydmFibGU8VFthXVtiXT47XG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBzZWxlY3Q8VCwgYSBleHRlbmRzIGtleW9mIFQsIGIgZXh0ZW5kcyBrZXlvZiBUW2FdLCBjIGV4dGVuZHMga2V5b2YgVFthXVtiXT4oa2V5MTogYSwga2V5MjogYiwga2V5MzogYyk6IChzb3VyY2UkOiBPYnNlcnZhYmxlPFQ+KSA9PiBPYnNlcnZhYmxlPFRbYV1bYl1bY10+O1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gc2VsZWN0PFQsIGEgZXh0ZW5kcyBrZXlvZiBULCBiIGV4dGVuZHMga2V5b2YgVFthXSwgYyBleHRlbmRzIGtleW9mIFRbYV1bYl0sIGQgZXh0ZW5kcyBrZXlvZiBUW2FdW2JdW2NdPihrZXkxOiBhLCBrZXkyOiBiLCBrZXkzOiBjLCBrZXk0OiBkKTogKHNvdXJjZSQ6IE9ic2VydmFibGU8VD4pID0+IE9ic2VydmFibGU8VFthXVtiXVtjXVtkXT47XG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBzZWxlY3Q8VCwgYSBleHRlbmRzIGtleW9mIFQsIGIgZXh0ZW5kcyBrZXlvZiBUW2FdLCBjIGV4dGVuZHMga2V5b2YgVFthXVtiXSwgZCBleHRlbmRzIGtleW9mIFRbYV1bYl1bY10sIGUgZXh0ZW5kcyBrZXlvZiBUW2FdW2JdW2NdW2RdPihrZXkxOiBhLCBrZXkyOiBiLCBrZXkzOiBjLCBrZXk0OiBkLCBrZXk1OiBlKTogKHNvdXJjZSQ6IE9ic2VydmFibGU8VD4pID0+IE9ic2VydmFibGU8VFthXVtiXVtjXVtkXVtlXT47XG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBzZWxlY3Q8VCwgYSBleHRlbmRzIGtleW9mIFQsIGIgZXh0ZW5kcyBrZXlvZiBUW2FdLCBjIGV4dGVuZHMga2V5b2YgVFthXVtiXSwgZCBleHRlbmRzIGtleW9mIFRbYV1bYl1bY10sIGUgZXh0ZW5kcyBrZXlvZiBUW2FdW2JdW2NdW2RdLCBmIGV4dGVuZHMga2V5b2YgVFthXVtiXVtjXVtkXVtlXT4oa2V5MTogYSwga2V5MjogYiwga2V5MzogYywga2V5NDogZCwga2V5NTogZSwga2V5NjogZik6IChzb3VyY2UkOiBPYnNlcnZhYmxlPFQ+KSA9PiBPYnNlcnZhYmxlPFRbYV1bYl1bY11bZF1bZV1bZl0+O1xuLyoqXG4gKiBUaGlzIG92ZXJsb2FkIGlzIHVzZWQgdG8gc3VwcG9ydCBzcHJlYWQgb3BlcmF0b3Igd2l0aFxuICogZml4ZWQgbGVuZ3RoIHR1cGxlcyB0eXBlIGluIHR5cGVzY3JpcHQgMi43XG4gKi9cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIHNlbGVjdDxULCBQcm9wcyA9IGFueSwgSyA9IGFueT4ocHJvcHNPclBhdGg6IFByb3BzLCAuLi5wYXRoczogc3RyaW5nW10pOiAoc291cmNlJDogT2JzZXJ2YWJsZTxUPikgPT4gT2JzZXJ2YWJsZTxLPjtcbiJdfQ==